name: üçé macOS Build

on:
  workflow_call:
    inputs:
      tag:
        description: 'Git tag for release builds.'
        required: false
        type: string
      flutter-version:
        description: 'Flutter version (optional).'
        required: false
        type: string
        # default: '3.27.2'

  # Triggers on Pull Requests targeting main
  pull_request:
    branches:
      - main
      - feat/beau/ci-macos

  # Allows manual triggering
  workflow_dispatch:

jobs:
  build-macos:
    name: üçé Build and Deploy macOS
    runs-on: macos-latest
    env:
      APP_NAME: Flites
      APP_ID: app.flites.editor
      APP_NAME_LOWER: flites
    steps:
      - name: DEBUG Print Workflow Input Tag
        if: github.event_name == 'workflow_call'
        run: |
         echo "Workflow Input (inputs.tag): ${{ inputs.tag }}"
        shell: bash # Use bash on macOS runner

      - name: üìö Git Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_call' && inputs.tag || github.ref }}

      - name: Determine Build Context & Variables
        id: vars
        uses: ./.github/actions/determine_build_vars
        with:
          platform: 'macos' # Specify platform as macos
          event_name: ${{ github.event_name }}
          tag_input: ${{ inputs.tag }}
          pr_number: ${{ github.event.number }}
          run_id: ${{ github.run_id }}

      - name: üì¶ Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ inputs.flutter-version || '3.27.2' }}
          # Check runner image docs for available architectures on macOS runners if needed
          architecture: x64 # Or arm64, or build universal if required/supported
          cache: true

      - name: üì¶ Setup Melos
        uses: bluefireteam/melos-action@v2

      - name: ‚ú® Super Clean Build Environment
        shell: bash
        run: |
          echo "üßπ Cleaning Flutter project..."
          cd apps/flites
          flutter clean
          echo "üßπ Cleaning Xcode derived data and Pods..."
          cd macos
          xcodebuild clean || echo "Xcode clean failed or no project to clean (continuing)."
          rm -rf Pods
          rm -f Podfile.lock
          cd ../../ # Go back to workspace root if needed for next steps
          echo "‚ú® Clean finished."

      - name: üîß Install Dependencies
        run: |
          flutter config --enable-macos-desktop
          flutter doctor -v
        shell: bash

      - name: üîÑ Get Dependencies
        run: melos bootstrap
        shell: bash

      # Build macOS App
      - name: üèóÔ∏è Build macOS App
        run: |
          cd apps/flites # Ensure you are in the right directory
          echo "Building macOS app version ${{ steps.vars.outputs.package_version }}"
          flutter build macos --release
        shell: bash

      # --- Code Signing & Notarization (Placeholder - IMPORTANT for distribution) ---
      # These steps would typically go AFTER the build and BEFORE zipping.
      # They require secrets configured in your repository (Apple Developer Certs/Keys).

      - name: üçé Install Apple Certificate and Key
        # if: steps.vars.outputs.build_type == 'release' # Only sign releases
        uses: apple-actions/import-codesign-certs@v2
        with:
          p12-file-base64: ${{ secrets.MACOS_CERTIFICATE_P12_BASE64 }}
          p12-password: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}

      - name: üçé Sign macOS App
        # if: steps.vars.outputs.build_type == 'release'
        run: |
          ENTITLEMENTS_PATH="apps/flites/macos/Runner/Release.entitlements"
          APP_BUNDLE_PATH="apps/flites/build/macos/Build/Products/Release/${{ env.APP_NAME_LOWER }}.app"
          FRAMEWORK_DIR="${APP_BUNDLE_PATH}/Contents/Frameworks"
          SIGNING_IDENTITY="${{ secrets.MACOS_CERTIFICATE_SIGNING_IDENTITY }}"

          FRAMEWORKS_TO_SIGN=(
            "file_picker.framework"
            "file_saver.framework"
            "url_launcher_macos.framework"
            # Add any other problematic frameworks here if they appear in future logs
          )

          echo "Using entitlements file: ${ENTITLEMENTS_PATH}"
          ls -l "${ENTITLEMENTS_PATH}" # Verify file exists

          for FRAMEWORK_NAME in "${FRAMEWORKS_TO_SIGN[@]}"; do
            FRAMEWORK_BINARY_PATH="${FRAMEWORK_DIR}/${FRAMEWORK_NAME}/Versions/A/${FRAMEWORK_NAME%.*}" # Gets "file_picker" from "file_picker.framework"
            FRAMEWORK_BUNDLE_PATH="${FRAMEWORK_DIR}/${FRAMEWORK_NAME}"

            echo "Attempting to sign framework binary: ${FRAMEWORK_BINARY_PATH}"
            codesign --remove-signature "${FRAMEWORK_BINARY_PATH}" || echo "No existing signature on binary ${FRAMEWORK_BINARY_PATH}, or removal failed (continuing)."
            codesign --force --strict --options=runtime --timestamp --sign "${SIGNING_IDENTITY}" "${FRAMEWORK_BINARY_PATH}"
            
            echo "Attempting to sign framework bundle: ${FRAMEWORK_BUNDLE_PATH}"
            codesign --remove-signature "${FRAMEWORK_BUNDLE_PATH}" || echo "No existing signature on bundle ${FRAMEWORK_BUNDLE_PATH}, or removal failed (continuing)."
            codesign --force --strict --options=runtime --timestamp --sign "${SIGNING_IDENTITY}" "${FRAMEWORK_BUNDLE_PATH}"
          done

          echo "Signing main application bundle: ${APP_BUNDLE_PATH}"
          codesign --force --deep --strict --options=runtime --timestamp \
            --entitlements "${ENTITLEMENTS_PATH}" \
            --sign "${SIGNING_IDENTITY}" \
            "${APP_BUNDLE_PATH}"
        shell: bash

      - name: üîé Verify Signatures After Signing
        shell: bash
        run: |
          APP_BUNDLE_PATH="apps/flites/build/macos/Build/Products/Release/${{ env.APP_NAME_LOWER }}.app"
          echo "Verifying signature for main app: ${APP_BUNDLE_PATH}"
          codesign --display --verbose=4 "${APP_BUNDLE_PATH}"
          echo "\nVerifying signature for file_picker framework:"
          codesign --display --verbose=4 "${APP_BUNDLE_PATH}/Contents/Frameworks/file_picker.framework"
          echo "\nVerifying signature for url_launcher_macos framework:"
          codesign --display --verbose=4 "${APP_BUNDLE_PATH}/Contents/Frameworks/url_launcher_macos.framework"
          echo "\nChecking for hardened runtime and entitlements on main app:"
          codesign -d --entitlements :- "${APP_BUNDLE_PATH}"

      # Package .app into Zip using ditto (preserves metadata/permissions better for .app)
      - name: üì¶ Package macOS Build into Zip
        shell: bash
        run: |
          # Adjust source path if needed. Assumes app bundle name matches APP_NAME_LOWER.
          SOURCE_APP="apps/flites/build/macos/Build/Products/Release/${{ env.APP_NAME_LOWER }}.app"
          # Get zip filename from composite action output (should end in .zip)
          ZIP_FILE_NAME="${{ steps.vars.outputs.artifact_suffix }}"
          # Get absolute path to workspace root
          WORKSPACE_ROOT="${{ github.workspace }}"

          # Check if source app bundle exists
          if [ ! -d "${SOURCE_APP}" ]; then
            echo "Build output (.app) not found: ${SOURCE_APP}"
            ls -lR "apps/flites/build/macos/Build/Products/Release/" # List build output for debugging
            exit 1
          fi

          echo "Zipping ${SOURCE_APP} into ${WORKSPACE_ROOT}/${ZIP_FILE_NAME}"
          # Use ditto: -c=create archive, -k=pkzip format, --sequesterRsrc=AppleDouble format, --keepParent=embed in parent folder structure (use .)
          # The command zips the SOURCE_APP into the ZIP_FILE_NAME at the workspace root
          ditto -c -k --sequesterRsrc --keepParent "${SOURCE_APP}" "${WORKSPACE_ROOT}/${ZIP_FILE_NAME}"

          # Verify zip file was created
          echo "Verifying zip file:"
          ls -l "${WORKSPACE_ROOT}/${ZIP_FILE_NAME}"
          echo "Created ${ZIP_FILE_NAME}"

      # Notarization step would usually happen AFTER zipping the signed app
      - name: üçé Notarize macOS App
        # if: steps.vars.outputs.build_type == 'release'
        uses: GuillaumeFalourd/notary-tools@v1 # Replaced apple-actions/upload-app-notary-submission@v2
        with:
          product_path: ${{ steps.vars.outputs.artifact_suffix }} # Path to the SIGNED ZIP file
          apple_id: ${{ secrets.APPLE_ID }} # Store your Apple ID email in secrets
          password: ${{ secrets.APPLE_PASSWORD }} # Store an app-specific password in secrets
          team_id: ${{ secrets.APPLE_TEAM_ID }} # Store your Apple Developer Team ID in secrets
          xcode_path: /Applications/Xcode.app # Explicitly set Xcode path
          staple: false # Temporarily disable stapling
          # keychain_profile: 'your-keychain-profile-name' # Optional: defaults to 'notarization'

      # Upload the created zip artifact
      - name: ‚¨ÜÔ∏è Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.vars.outputs.artifact_upload_name }}
          # Path points to the zip file created by ditto
          path: ${{ steps.vars.outputs.artifact_suffix }}

      # Minimal test for macOS build - check if .app was created before zipping
      - name: üß™ Test macOS Build (Basic Check)
        shell: bash
        run: |
          # Check if the .app bundle directory was created by the build step
          APP_BUNDLE="apps/flites/build/macos/Build/Products/Release/${{ env.APP_NAME_LOWER }}.app" # Use lowercase to match pubspec
          echo "Checking for ${APP_BUNDLE}"
          if [ -d "${APP_BUNDLE}" ]; then
            echo "macOS build output (.app bundle) found."
          else
            echo "Error: macOS build output (.app bundle) not found!"
            exit 1
          fi