name: üçé macOS Build

on:
  workflow_call:
    inputs:
      tag:
        description: 'Git tag for release builds.'
        required: false
        type: string
      flutter-version:
        description: 'Flutter version (optional).'
        required: false
        type: string
        # default: '3.27.2'

  # Triggers on Pull Requests targeting main
  pull_request:
    branches:
      - main
      - feat/beau/ci-macos

  # Allows manual triggering
  workflow_dispatch:

jobs:
  build-macos:
    name: üçé Build and Deploy macOS
    runs-on: macos-latest
    env:
      APP_NAME: Flites
      APP_ID: app.flites.editor
      APP_NAME_LOWER: flites
    steps:
      - name: DEBUG Print Workflow Input Tag
        if: github.event_name == 'workflow_call'
        run: |
         echo "Workflow Input (inputs.tag): ${{ inputs.tag }}"
        shell: bash # Use bash on macOS runner

      - name: üìö Git Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_call' && inputs.tag || github.ref }}

      - name: Determine Build Context & Variables
        id: vars
        uses: ./.github/actions/determine_build_vars
        with:
          platform: 'macos' # Specify platform as macos
          event_name: ${{ github.event_name }}
          tag_input: ${{ inputs.tag }}
          pr_number: ${{ github.event.number }}
          run_id: ${{ github.run_id }}

      - name: üì¶ Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ inputs.flutter-version || '3.27.2' }}
          # Check runner image docs for available architectures on macOS runners if needed
          architecture: x64 # Or arm64, or build universal if required/supported
          cache: true

      - name: üì¶ Setup Melos
        uses: bluefireteam/melos-action@v2

      - name: ‚ú® Super Clean Build Environment
        shell: bash
        run: |
          echo "üßπ Cleaning Flutter project..."
          cd apps/flites
          flutter clean
          echo "üßπ Cleaning Xcode derived data and Pods..."
          cd macos
          xcodebuild clean || echo "Xcode clean failed or no project to clean (continuing)."
          rm -rf Pods
          rm -f Podfile.lock
          cd ../../ # Go back to workspace root if needed for next steps
          echo "‚ú® Clean finished."

      - name: üîß Install Dependencies
        run: |
          flutter config --enable-macos-desktop
          flutter doctor -v
        shell: bash

      - name: üîÑ Get Dependencies
        run: melos bootstrap
        shell: bash

      # Build macOS App
      - name: üèóÔ∏è Build macOS App
        run: |
          cd apps/flites # Ensure you are in the right directory
          echo "Building macOS app version ${{ steps.vars.outputs.package_version }}"
          flutter build macos --release
        shell: bash

      # --- Code Signing & Notarization (Placeholder - IMPORTANT for distribution) ---
      # These steps would typically go AFTER the build and BEFORE zipping.
      # They require secrets configured in your repository (Apple Developer Certs/Keys).

      - name: üçé Install Apple Certificate and Key
        # if: steps.vars.outputs.build_type == 'release' # Only sign releases
        uses: apple-actions/import-codesign-certs@v2
        with:
          p12-file-base64: ${{ secrets.MACOS_CERTIFICATE_P12_BASE64 }}
          p12-password: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}

      - name: üçé Sign macOS App
        # if: steps.vars.outputs.build_type == 'release'
        run: |
          ENTITLEMENTS_PATH="apps/flites/macos/Runner/Release.entitlements"
          APP_BUNDLE_PATH="apps/flites/build/macos/Build/Products/Release/${{ env.APP_NAME_LOWER }}.app"
          SIGNING_IDENTITY="${{ secrets.MACOS_CERTIFICATE_SIGNING_IDENTITY }}"

          echo "Using entitlements file: ${ENTITLEMENTS_PATH}"
          ls -l "${ENTITLEMENTS_PATH}" # Verify file exists

          # Step 1: First remove any existing signatures from the entire app bundle
          echo "Removing any existing signatures from the app bundle"
          codesign --remove-signature "${APP_BUNDLE_PATH}" || echo "No existing signature or removal failed (continuing)."

          # Step 2: Find and sign all executables and libraries within the app bundle, starting with the deepest components
          echo "Signing all executables and libraries within the app bundle"
          find "${APP_BUNDLE_PATH}" -type f -name "*.dylib" -o -path "*/Versions/A/*" -not -path "*.bundle*" | while read -r BINARY; do
            if [[ -f "$BINARY" ]] && file "$BINARY" | grep -q "Mach-O"; then
              echo "Signing binary: $BINARY"
              codesign --force --options=runtime --timestamp --sign "${SIGNING_IDENTITY}" "$BINARY"
            fi
          done

          # Step 3: Sign all framework bundles
          echo "Signing all framework bundles"
          find "${APP_BUNDLE_PATH}" -type d -name "*.framework" | while read -r FRAMEWORK; do
            echo "Signing framework bundle: $FRAMEWORK"
            codesign --force --options=runtime --timestamp --sign "${SIGNING_IDENTITY}" "$FRAMEWORK"
          done

          # Step 4: Sign all embedded .app bundles if any
          echo "Signing any embedded app bundles"
          find "${APP_BUNDLE_PATH}" -type d -name "*.app" -not -path "${APP_BUNDLE_PATH}" | while read -r EMBEDDED_APP; do
            echo "Signing embedded app: $EMBEDDED_APP"
            codesign --force --options=runtime --timestamp --entitlements "${ENTITLEMENTS_PATH}" --sign "${SIGNING_IDENTITY}" "$EMBEDDED_APP"
          done

          # Step 5: Finally sign the main app bundle with entitlements
          echo "Signing main application bundle: ${APP_BUNDLE_PATH}"
          codesign --force --deep --strict --options=runtime --timestamp \
            --entitlements "${ENTITLEMENTS_PATH}" \
            --sign "${SIGNING_IDENTITY}" \
            "${APP_BUNDLE_PATH}"
        shell: bash

      - name: üîé Verify Signatures After Signing
        shell: bash
        run: |
          APP_BUNDLE_PATH="apps/flites/build/macos/Build/Products/Release/${{ env.APP_NAME_LOWER }}.app"
          
          echo "Verifying signature for main app bundle:"
          codesign --verify --deep --strict "${APP_BUNDLE_PATH}" && echo "‚úÖ App bundle passed verification" || echo "‚ùå App bundle verification failed"
          codesign --display --verbose=4 "${APP_BUNDLE_PATH}"
          
          echo "\nChecking codesign entitlements on main app:"
          codesign -d --entitlements :- "${APP_BUNDLE_PATH}"
          
          echo "\nVerifying all frameworks signed correctly:"
          find "${APP_BUNDLE_PATH}/Contents/Frameworks" -name "*.framework" -maxdepth 1 | while read -r FRAMEWORK; do
            echo "\nVerifying $FRAMEWORK:"
            codesign --verify --strict "${FRAMEWORK}" && echo "‚úÖ Framework passed verification" || echo "‚ùå Framework verification failed"
            codesign --display --verbose=2 "${FRAMEWORK}"
          done
          
          echo "\nVerifying with spctl assessment (Gatekeeper):"
          spctl --assess --type exec --verbose "${APP_BUNDLE_PATH}" || echo "‚ö†Ô∏è App failed spctl assessment (expected before notarization)"

      # Package .app into Zip using ditto (preserves metadata/permissions better for .app)
      - name: üì¶ Package macOS Build into Zip
        shell: bash
        run: |
          # Adjust source path if needed. Assumes app bundle name matches APP_NAME_LOWER.
          SOURCE_APP="apps/flites/build/macos/Build/Products/Release/${{ env.APP_NAME_LOWER }}.app"
          # Get zip filename from composite action output (should end in .zip)
          ZIP_FILE_NAME="${{ steps.vars.outputs.artifact_suffix }}"
          # Get absolute path to workspace root
          WORKSPACE_ROOT="${{ github.workspace }}"

          # Check if source app bundle exists
          if [ ! -d "${SOURCE_APP}" ]; then
            echo "Build output (.app) not found: ${SOURCE_APP}"
            ls -lR "apps/flites/build/macos/Build/Products/Release/" # List build output for debugging
            exit 1
          fi

          echo "Zipping ${SOURCE_APP} into ${WORKSPACE_ROOT}/${ZIP_FILE_NAME}"
          # Use ditto: -c=create archive, -k=pkzip format, --sequesterRsrc=AppleDouble format, --keepParent=embed in parent folder structure (use .)
          # The command zips the SOURCE_APP into the ZIP_FILE_NAME at the workspace root
          ditto -c -k --sequesterRsrc --keepParent "${SOURCE_APP}" "${WORKSPACE_ROOT}/${ZIP_FILE_NAME}"

          # Verify zip file was created
          echo "Verifying zip file:"
          ls -l "${WORKSPACE_ROOT}/${ZIP_FILE_NAME}"
          echo "Created ${ZIP_FILE_NAME}"

      # Notarization step would usually happen AFTER zipping the signed app
      - name: üçé Notarize macOS App
        id: notarize
        # if: steps.vars.outputs.build_type == 'release'
        uses: GuillaumeFalourd/notary-tools@v1 # Replaced apple-actions/upload-app-notary-submission@v2
        with:
          product_path: ${{ steps.vars.outputs.artifact_suffix }} # Path to the SIGNED ZIP file
          apple_id: ${{ secrets.APPLE_ID }} # Store your Apple ID email in secrets
          password: ${{ secrets.APPLE_PASSWORD }} # Store an app-specific password in secrets
          team_id: ${{ secrets.APPLE_TEAM_ID }} # Store your Apple Developer Team ID in secrets
          xcode_path: /Applications/Xcode.app # Explicitly set Xcode path
          staple: false # Temporarily disable stapling
          # keychain_profile: 'your-keychain-profile-name' # Optional: defaults to 'notarization'

      - name: üìã Get Notarization Logs If Available
        if: always() # Run even if notarization fails
        shell: bash
        run: |
          echo "Retrieving detailed notarization logs if available..."
          
          # Store Apple credentials in keychain temporarily for using notarytool
          KEYCHAIN_PATH="${RUNNER_TEMP}/notarization_temp.keychain-db"
          KEYCHAIN_PASSWORD="$(uuidgen)"
          
          # Create temporary keychain
          security create-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"
          security default-keychain -s "${KEYCHAIN_PATH}"
          security unlock-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"
          
          # Store credentials in keychain
          xcrun notarytool store-credentials "temp-profile" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --team-id "${{ secrets.APPLE_TEAM_ID }}" \
            --password "${{ secrets.APPLE_PASSWORD }}" \
            --keychain "${KEYCHAIN_PATH}"
            
          # Try to get the submission ID from the previous step's output
          # If submission ID is available, get detailed log
          if [[ "${{ steps.notarize.outputs.id }}" != "" ]]; then
            SUBMISSION_ID="${{ steps.notarize.outputs.id }}"
            echo "Getting log for submission ID: ${SUBMISSION_ID}"
            xcrun notarytool log "${SUBMISSION_ID}" \
              --keychain-profile "temp-profile" \
              --keychain "${KEYCHAIN_PATH}" \
              --output notarization-log.json
              
            # Display the log in a human-readable format
            echo "Notarization log content:"
            cat notarization-log.json | jq '.'
          else
            echo "No submission ID found, cannot retrieve log."
          fi
          
          # Clean up
          security delete-keychain "${KEYCHAIN_PATH}"

      # Upload the created zip artifact
      - name: ‚¨ÜÔ∏è Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.vars.outputs.artifact_upload_name }}
          # Path points to the zip file created by ditto
          path: ${{ steps.vars.outputs.artifact_suffix }}

      # Minimal test for macOS build - check if .app was created before zipping
      - name: üß™ Test macOS Build (Basic Check)
        shell: bash
        run: |
          # Check if the .app bundle directory was created by the build step
          APP_BUNDLE="apps/flites/build/macos/Build/Products/Release/${{ env.APP_NAME_LOWER }}.app" # Use lowercase to match pubspec
          echo "Checking for ${APP_BUNDLE}"
          if [ -d "${APP_BUNDLE}" ]; then
            echo "macOS build output (.app bundle) found."
          else
            echo "Error: macOS build output (.app bundle) not found!"
            exit 1
          fi